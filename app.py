# --- PARTIE 1: IMPORTS ET CONFIGURATION ---
import os
import re
from dotenv import load_dotenv
from typing import Dict, Any, Optional
import json

# Imports de LangChain
from langchain_community.utilities import SQLDatabase
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.chains import create_sql_query_chain
from langchain_community.tools.sql_database.tool import QuerySQLDataBaseTool
from operator import itemgetter
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough

# Charger les variables d'environnement
load_dotenv()

# V√©rifier que la cl√© API est bien charg√©e
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    raise ValueError("Cl√© API Google manquante...")

# --- PARTIE 2: CONFIGURATION MULTI-BASES DE DONN√âES ---

class DatabaseConfig:
    """Gestionnaire de configuration pour diff√©rents types de bases de donn√©es"""
    
    # Configurations pr√©d√©finies pour diff√©rents types de BDD
    DB_CONFIGS = {
        "sqlite": {
            "driver": "sqlite",
            "port": None,
            "example_uri": "sqlite:///ma_base.db",
            "description": "Base de donn√©es SQLite locale",
            "required_env": []
        },
        "postgresql": {
            "driver": "postgresql+psycopg2",
            "port": 5432,
            "example_uri": "postgresql+psycopg2://user:password@localhost:5432/database",
            "description": "Base de donn√©es PostgreSQL",
            "required_env": ["DB_USER", "DB_PASSWORD", "DB_HOST", "DB_NAME"]
        },
        "mysql": {
            "driver": "mysql+pymysql",
            "port": 3306,
            "example_uri": "mysql+pymysql://user:password@localhost:3306/database",
            "description": "Base de donn√©es MySQL",
            "required_env": ["DB_USER", "DB_PASSWORD", "DB_HOST", "DB_NAME"]
        },
        "mariadb": {
            "driver": "mariadb+pymysql",
            "port": 3306,
            "example_uri": "mariadb+pymysql://user:password@localhost:3306/database",
            "description": "Base de donn√©es MariaDB",
            "required_env": ["DB_USER", "DB_PASSWORD", "DB_HOST", "DB_NAME"]
        },
        "mssql": {
            "driver": "mssql+pyodbc",
            "port": 1433,
            "example_uri": "mssql+pyodbc://user:password@server:1433/database?driver=ODBC+Driver+17+for+SQL+Server",
            "description": "Base de donn√©es SQL Server",
            "required_env": ["DB_USER", "DB_PASSWORD", "DB_HOST", "DB_NAME"]
        },
        "oracle": {
            "driver": "oracle+cx_oracle",
            "port": 1521,
            "example_uri": "oracle+cx_oracle://user:password@localhost:1521/xe",
            "description": "Base de donn√©es Oracle",
            "required_env": ["DB_USER", "DB_PASSWORD", "DB_HOST", "DB_NAME"]
        }
    }
    
    @classmethod
    def list_supported_databases(cls):
        """Affiche la liste des bases de donn√©es support√©es"""
        print("\nüóÑÔ∏è  Bases de donn√©es support√©es :")
        print("=" * 50)
        for db_type, config in cls.DB_CONFIGS.items():
            print(f"‚Ä¢ {db_type.upper()}: {config['description']}")
            print(f"  Port par d√©faut: {config['port'] or 'N/A'}")
            print(f"  Exemple URI: {config['example_uri']}")
            print()
    
    @classmethod
    def build_uri_from_env(cls, db_type: str) -> str:
        """Construit l'URI de connexion √† partir des variables d'environnement"""
        if db_type not in cls.DB_CONFIGS:
            raise ValueError(f"Type de base de donn√©es non support√©: {db_type}")
        
        config = cls.DB_CONFIGS[db_type]
        
        # Pour SQLite, utiliser directement le chemin du fichier
        if db_type == "sqlite":
            db_path = os.getenv("DB_PATH", "ma_base.db")
            return f"sqlite:///{db_path}"
        
        # Pour les autres BDD, construire l'URI compl√®te
        required_vars = config["required_env"]
        missing_vars = [var for var in required_vars if not os.getenv(var)]
        
        if missing_vars:
            raise ValueError(f"Variables d'environnement manquantes pour {db_type}: {missing_vars}")
        
        user = os.getenv("DB_USER")
        password = os.getenv("DB_PASSWORD")
        host = os.getenv("DB_HOST", "localhost")
        port = os.getenv("DB_PORT", str(config["port"]))
        database = os.getenv("DB_NAME")
        
        driver = config["driver"]
        
        # Construction de l'URI selon le type de BDD
        if db_type in ["postgresql", "mysql", "mariadb"]:
            return f"{driver}://{user}:{password}@{host}:{port}/{database}"
        elif db_type == "mssql":
            driver_param = os.getenv("ODBC_DRIVER", "ODBC+Driver+17+for+SQL+Server")
            return f"{driver}://{user}:{password}@{host}:{port}/{database}?driver={driver_param}"
        elif db_type == "oracle":
            service_name = os.getenv("DB_SERVICE_NAME", "xe")
            return f"{driver}://{user}:{password}@{host}:{port}/{service_name}"
        
        return f"{driver}://{user}:{password}@{host}:{port}/{database}"

def get_database_connection() -> SQLDatabase:
    """√âtablit la connexion √† la base de donn√©es selon la configuration"""
    
    # M√©thode 1: URI directe dans .env
    db_uri = os.getenv("DATABASE_URL")
    if db_uri:
        print(f"üì° Connexion via DATABASE_URL...")
        return create_safe_db_connection(db_uri)
    
    # M√©thode 2: Configuration par type de BDD
    db_type = os.getenv("DB_TYPE", "sqlite").lower()
    print(f"üì° Connexion √† une base de donn√©es {db_type.upper()}...")
    
    try:
        db_uri = DatabaseConfig.build_uri_from_env(db_type)
        print(f"üîó URI g√©n√©r√©e: {db_uri.split('@')[0]}@***" if '@' in db_uri else db_uri)
        return create_safe_db_connection(db_uri)
    except Exception as e:
        print(f"‚ùå Erreur de configuration pour {db_type}: {e}")
        print("\nüí° V√©rifiez votre fichier .env ou utilisez DATABASE_URL directement")
        DatabaseConfig.list_supported_databases()
        raise

def create_safe_db_connection(db_uri: str) -> SQLDatabase:
    """Cr√©e une connexion s√©curis√©e avec gestion des permissions limit√©es"""
    
    print(f"üîå Tentative de connexion...")
    
    # Essai 1: Connexion standard
    try:
        db = SQLDatabase.from_uri(db_uri, connect_argrs={"connect_timeout": 10})
        print("‚úÖ Connexion standard r√©ussie")
        return db
    except Exception as e:
        print(f"‚ö†Ô∏è  Connexion standard √©chou√©e: {str(e)[:100]}...")
        
        # Essai 2: Connexion avec param√®tres restreints
        if "permission denied" in str(e).lower() or "insufficient" in str(e).lower():
            print("üîÑ Tentative en mode restreint...")
            try:
                db = SQLDatabase.from_uri(
                    db_uri,
                    sample_rows_in_table_info=1,
                    max_string_length=100,
                    lazy_table_reflection=True  
                )
                print("‚úÖ Connexion restreinte r√©ussie")
                return db
            except Exception as e2:
                print(f"‚ö†Ô∏è  Mode restreint √©chou√©: {str(e2)[:100]}...")
        
        # Essai 3: Connexion SQLAlchemy directe
        print("üîÑ Tentative avec SQLAlchemy direct...")
        try:
            import sqlalchemy
            from sqlalchemy import create_engine
            
            engine = create_engine(db_uri)
            
            # Test de connexion basique
            with engine.connect() as conn:
                conn.execute(sqlalchemy.text("SELECT 1"))
            
            # Cr√©er l'objet SQLDatabase manuellement
            db = SQLDatabase(engine=engine)
            print("‚úÖ Connexion SQLAlchemy directe r√©ussie")
            return db
            
        except Exception as e3:
            print(f"‚ùå Toutes les tentatives ont √©chou√©")
            print(f"Derni√®re erreur: {str(e3)[:200]}...")
            
            # Diagnostic plus d√©taill√©
            if "could not connect" in str(e3).lower():
                print("üîç Probl√®me de connectivit√© r√©seau ou de serveur")
            elif "authentication" in str(e3).lower() or "password" in str(e3).lower():
                print("üîç Probl√®me d'authentification (login/mot de passe)")
            elif "database" in str(e3).lower() and "does not exist" in str(e3).lower():
                print("üîç La base de donn√©es sp√©cifi√©e n'existe pas")
            elif "driver" in str(e3).lower():
                print("üîç Driver de base de donn√©es manquant")
                db_type = os.getenv("DB_TYPE", "").lower()
                if db_type == "postgresql":
                    print("üí° Installez: pip install psycopg2-binary")
                elif db_type == "mysql":
                    print("üí° Installez: pip install pymysql")
                elif db_type == "mssql":
                    print("üí° Installez: pip install pyodbc")
            
            raise Exception(f"Impossible de se connecter: {str(e3)}")

# --- PARTIE 3: PROMPTS ADAPT√âS PAR TYPE DE BDD ---

def get_database_specific_prompt(db_type: str) -> str:
    """Retourne un prompt adapt√© au type de base de donn√©es"""
    
    base_prompt = """Tu es un expert en bases de donn√©es. G√©n√®re une requ√™te SQL pour r√©pondre √† la question de l'utilisateur.
    
R√®gles importantes:
- Utilise uniquement les tables et colonnes qui existent dans le sch√©ma fourni
- La requ√™te doit √™tre syntaxiquement correcte pour {db_type}
- Limite les r√©sultats √† 100 lignes maximum avec LIMIT
- Pour les recherches textuelles, utilise la syntaxe appropri√©e √† {db_type}
- N'utilise que SELECT, pas de modification de donn√©es
"""
    
    # Ajouts sp√©cifiques par type de BDD
    db_specifics = {
        "sqlite": "- Utilise LIKE pour les recherches textuelles (sensible √† la casse)\n- Date/time avec strftime() si n√©cessaire",
        "postgresql": "- Utilise ILIKE pour les recherches insensibles √† la casse\n- Fonctions PostgreSQL natives disponibles",
        "mysql": "- Utilise LIKE (insensible √† la casse par d√©faut)\n- Fonctions MySQL disponibles",
        "mssql": "- Utilise LIKE avec COLLATE pour contr√¥ler la casse\n- Fonctions SQL Server disponibles",
        "oracle": "- Utilise UPPER() avec LIKE pour recherches insensibles √† la casse\n- Fonctions Oracle disponibles"
    }
    
    specific_rules = db_specifics.get(db_type, "- Utilise la syntaxe SQL standard")
    
    return base_prompt.format(db_type=db_type.upper()) + "\n" + specific_rules

# --- PARTIE 4: CONNEXION ET CONFIGURATION DU MOD√àLE ---

try:
    # Connexion √† la base de donn√©es
    db = get_database_connection()
    
    # D√©tecter le type de BDD √† partir de l'URI
    try:
        # Essayer diff√©rentes fa√ßons d'acc√©der √† l'URL de la BDD selon la version de LangChain
        if hasattr(db, 'engine'):
            db_uri_lower = str(db.engine.url).lower()
        elif hasattr(db, '_engine'):
            db_uri_lower = str(db._engine.url).lower()
        elif hasattr(db, 'database_uri'):
            db_uri_lower = str(db.database_uri).lower()
        else:
            # Fallback : essayer de r√©cup√©rer l'URI depuis les variables d'environnement
            env_uri = os.getenv("DATABASE_URL") or DatabaseConfig.build_uri_from_env(os.getenv("DB_TYPE", "sqlite"))
            db_uri_lower = env_uri.lower()
    except Exception as e:
        print(f"‚ö†Ô∏è  Impossible de d√©tecter le type de BDD automatiquement: {e}")
        # Fallback bas√© sur la configuration
        db_uri_lower = os.getenv("DB_TYPE", "sqlite").lower()
    if "sqlite" in db_uri_lower:
        detected_db_type = "sqlite"
    elif "postgresql" in db_uri_lower:
        detected_db_type = "postgresql"
    elif "mysql" in db_uri_lower or "mariadb" in db_uri_lower:
        detected_db_type = "mysql"
    elif "mssql" in db_uri_lower:
        detected_db_type = "mssql"
    elif "oracle" in db_uri_lower:
        detected_db_type = "oracle"
    else:
        detected_db_type = "unknown"
    
    print(f"‚úÖ Connexion r√©ussie ! Type d√©tect√©: {detected_db_type.upper()}")
    
    # Test de connexion s√©curis√©
    try:
        test_result = db.run("SELECT 1")
        print(f"üîç Test de connexion: OK")
        
        # Essayer d'obtenir des infos sur le sch√©ma de mani√®re s√©curis√©e
        try:
            table_info = db.get_table_info()
            if table_info and len(table_info) > 10:
                table_count = len([line for line in table_info.split('\n') if 'CREATE TABLE' in line.upper()])
                print(f"üìä Nombre de tables d√©tect√©es: {table_count}")
            else:
                print("üìä Sch√©ma: Acc√®s limit√© aux m√©tadonn√©es")
        except Exception as schema_error:
            print(f"üìä Sch√©ma: Acc√®s restreint ({str(schema_error)[:50]}...)")
            
            # Pour les BDD avec permissions limit√©es, on essaie une approche manuelle
            if detected_db_type == "postgresql":
                try:
                    # Requ√™te basique pour lister les tables publiques
                    tables_result = db.run("""
                        SELECT table_name 
                        FROM information_schema.tables 
                        WHERE table_schema = 'public' 
                        LIMIT 10
                    """)
                    print(f"üìã Tables publiques trouv√©es: {len(tables_result.split()) if tables_result else 0}")
                except Exception as e:
                    print(f"üìã Impossible de lister les tables: acc√®s tr√®s restreint")
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Attention: Test de connexion √©chou√©: {e}")
        # On continue quand m√™me, la connexion de base fonctionne peut-√™tre

except Exception as e:
    print(f"‚ùå Impossible de se connecter √† la base de donn√©es: {e}")
    print("\nüîß Solutions possibles:")
    print("1. V√©rifiez vos identifiants de connexion")
    print("2. V√©rifiez que l'utilisateur a les permissions n√©cessaires")
    print("3. Pour des BDD publiques, essayez avec des permissions limit√©es")
    print("\nExemple de fichier .env:")
    print("""
# Pour SQLite:
DB_TYPE=sqlite
DB_PATH=ma_base.db

# Pour PostgreSQL avec permissions limit√©es:
DB_TYPE=postgresql
DB_USER=reader
DB_PASSWORD=motdepasse
DB_HOST=serveur.com
DB_PORT=5432
DB_NAME=database_name

# Ou directement:
DATABASE_URL=postgresql://user:pass@host:port/db
    """)
    exit(1)

# Configuration du mod√®le LLM
llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash", temperature=0)

# --- PARTIE 5: CR√âATION DE LA CHA√éNE LANGCHAIN ADAPT√âE ---

# Cha√Æne pour √©crire la requ√™te SQL avec prompt adapt√©
write_query_chain = create_sql_query_chain(llm, db)

# Outil pour ex√©cuter la requ√™te SQL
execute_query_tool = QuerySQLDataBaseTool(db=db)

# Prompt pour la r√©ponse finale adapt√© au type de BDD
answer_prompt = PromptTemplate.from_template(
    f"""Tu es un assistant expert en bases de donn√©es {detected_db_type.upper()}.
    R√©ponds √† la question de l'utilisateur en fran√ßais de mani√®re claire et structur√©e.
    
    Si aucun r√©sultat n'est trouv√©, explique pourquoi de fa√ßon constructive.
    Si les r√©sultats sont nombreux, pr√©sente-les de mani√®re organis√©e.
    Si la requ√™te a des limites, mentionne-le √† l'utilisateur.

Question: {{question}}
Requ√™te SQL ({detected_db_type.upper()}): {{query}}
R√©sultat: {{result}}

R√©ponse d√©taill√©e: """
)

# Assemblage de la cha√Æne compl√®te
answer_chain = (
    RunnablePassthrough.assign(query=write_query_chain).assign(
        result=itemgetter("query") | execute_query_tool
    )
    | answer_prompt
    | llm
    | StrOutputParser()
)

# --- PARTIE 6: VALIDATION DE S√âCURIT√â ---

def validate_sql_query(query: str, db_type: str) -> bool:
    """Valide la requ√™te SQL pour √©viter les op√©rations dangereuses"""
    dangerous_keywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE', 'REPLACE']
    query_upper = query.upper()
    
    for keyword in dangerous_keywords:
        if keyword in query_upper:
            raise ValueError(f"‚ùå Requ√™te non autoris√©e d√©tect√©e: {keyword}")
    
    # V√©rifications sp√©cifiques par type de BDD
    if db_type == "mssql" and any(cmd in query_upper for cmd in ['EXEC', 'EXECUTE', 'SP_']):
        raise ValueError("‚ùå Ex√©cution de proc√©dures stock√©es non autoris√©e")
    
    return True

# --- PARTIE 7: INTERFACE UTILISATEUR AM√âLIOR√âE ---

print(f"""
ü§ñ Assistant SQL IA Multi-Bases de Donn√©es
Base de donn√©es: {detected_db_type.upper()}
Connexion: ‚úÖ Active

üí° Exemples de questions:
   ‚Ä¢ 'Combien de lignes dans chaque table ?'
   ‚Ä¢ 'Montre-moi les 10 premiers enregistrements de [table]'
   ‚Ä¢ 'Quelles sont les colonnes de la table [nom] ?'
   ‚Ä¢ 'Cherche tous les enregistrements contenant [terme]'

üìù Tapez 'quitter' pour arr√™ter
üìã Tapez 'schema' pour voir la structure des tables
""")

while True:
    question = input(f"\n[{detected_db_type.upper()}] Posez votre question : ")
    
    if question.lower() == 'quitter':
        print("üëã Au revoir !")
        break
    
    if question.lower() == 'schema':
        print("\nüìã Structure de la base de donn√©es:")
        print("=" * 50)
        try:
            schema_info = db.get_table_info()
            if schema_info and len(schema_info) > 10:
                print(schema_info[:2000] + "..." if len(schema_info) > 2000 else schema_info)
            else:
                print("‚ÑπÔ∏è  Informations de sch√©ma limit√©es. Essayons une approche alternative...")
                
                # Pour PostgreSQL avec permissions limit√©es
                if detected_db_type == "postgresql":
                    try:
                        tables_query = """
                        SELECT table_name, column_name, data_type 
                        FROM information_schema.columns 
                        WHERE table_schema = 'public' 
                        ORDER BY table_name, ordinal_position
                        LIMIT 50
                        """
                        result = db.run(tables_query)
                        print("Tables et colonnes disponibles:")
                        print(result)
                    except Exception as e:
                        print(f"Impossible d'acc√©der au sch√©ma: {e}")
                        print("üí° Essayez de poser des questions directement sur les donn√©es")
        except Exception as e:
            print(f"Erreur d'acc√®s au sch√©ma: {e}")
            print("üí° Permissions insuffisantes. Essayez des requ√™tes directes comme:")
            print("   ‚Ä¢ 'Montre-moi quelques lignes de la premi√®re table'")
            print("   ‚Ä¢ 'Liste les tables disponibles'")
        continue
    
    if not question.strip():
        continue

    try:
        print(f"\nüîç [D√âBOGAGE] Analyse de la question pour {detected_db_type.upper()}...")
        
        # G√©n√©ration de la requ√™te SQL
        generated_query = write_query_chain.invoke({"question": question})
        print(f"üìù Requ√™te g√©n√©r√©e:\n{generated_query}")
        
        # Nettoyage de la requ√™te
        cleaned_query = re.sub(r"```(?:\w+)?\s*", "", generated_query).replace("```", "").strip()
        
        # Validation de s√©curit√©
        validate_sql_query(cleaned_query, detected_db_type)
        
        # Ex√©cution de la requ√™te
        print(f"‚ö° Ex√©cution sur {detected_db_type.upper()}...")
        query_result = execute_query_tool.invoke({"query": cleaned_query})
        print(f"üìä R√©sultat obtenu: {len(str(query_result))} caract√®res")
        
        # G√©n√©ration de la r√©ponse finale
        final_prompt_input = {
            "question": question,
            "query": cleaned_query,
            "result": query_result
        }
        
        final_chain_part = answer_prompt | llm | StrOutputParser()
        response = final_chain_part.invoke(final_prompt_input)
        
        print(f"\n‚úÖ R√©ponse finale:")
        print("=" * 50)
        print(response)

    except ValueError as e:
        print(f"\nüö´ {e}")
    except Exception as e:
        print(f"\n‚ùå Erreur lors du traitement: {e}")
        if "syntax" in str(e).lower():
            print(f"üí° Cette erreur peut √™tre li√©e aux sp√©cificit√©s du dialecte SQL {detected_db_type.upper()}")